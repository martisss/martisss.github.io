<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="孩子，快逃！！！">
<meta property="og:type" content="website">
<meta property="og:title" content="Martisss&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Martisss&#39;s blog">
<meta property="og:description" content="孩子，快逃！！！">
<meta property="og:locale">
<meta property="article:author" content="martisss">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Martisss's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Martisss's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hello, world</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">TypeScript类型体操中的关键字详解（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 15:33:15 / 修改时间：15:38:19" itemprop="dateCreated datePublished" datetime="2022-06-07T15:33:15+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p><code>infer</code>这个词的含义即 推断，实际作用可以用四个字概括：<strong>类型推导</strong>。它会在类型未推导时进行占位，等到真正推导成功后，它能准确地返回正确的类型。</p>
<p>在这个条件语句 <code>T extends (...args: infer P) =&gt; any ? P : T</code> 中，<code>infer P</code> 表示待推断的函数参数。</p>
<p>整句含义为：如果 <code>T</code> 能赋值给 <code>(...args: infer P) =&gt; any</code>，则结果是 <code>(...args: infer P) =&gt; any</code> 类型中的参数 <code>P</code>，否则返回为 <code>T</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">user: User</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Param = ParamType&lt;Func&gt;; <span class="comment">// Param = User</span></span><br><span class="line"><span class="keyword">type</span> AA = ParamType&lt;<span class="built_in">string</span>&gt;; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p><code>infer</code>这个关键字在各种高级类型实现中出现频率很高，大部分情况下会与<code>extends</code>、<code>keyof</code>等关键字一起使用。</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><h2 id="infer只能在-extends-条件语句中使用，声明变量只能在true分支中使用"><a href="#infer只能在-extends-条件语句中使用，声明变量只能在true分支中使用" class="headerlink" title="infer只能在 extends 条件语句中使用，声明变量只能在true分支中使用"></a><strong><code>infer</code>只能在 extends 条件语句中使用，声明变量只能在true分支中使用</strong></h2><p>比如我想实现上文中<code>ParamType</code>类型，他接受一个函数类型，然后返回函数参数的类型。</p>
<p>用如下方式实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParameType&lt;T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span>&gt; = R</span><br><span class="line"><span class="comment">// error: &#x27;infer&#x27; declarations are only permitted in the &#x27;extends&#x27; clause of a conditional type.</span></span><br></pre></td></tr></table></figure>
<p>  大意就是<code>infer</code>只能在<code>extends</code>条件语句中使用，在<a target="_blank" rel="noopener" href="https://juejin.cn/post/7106038466139389959">extends详解</a>中我们提到<code>extends</code>关键字的使用场景大概有以下几种：<strong>接口继承、类型约束以及条件类型</strong>。在上述<code>ParameType</code>类型实现中，很明显这是属于类型约束的用法，想要实现该类型需要使用条件类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>T extends (...args: any) =&gt; infer P</code>：如果不看<code>infer R</code>，这段代码实际表示： <code>T</code>是不是一个函数类型。</li>
<li>  <code>(...args: any) =&gt; infer P</code>：这段代码实际表示一个函数类型，把它的参数使用<code>args</code>来表示，把它的返回类型用<code>P</code>来进行占位。</li>
<li>  如果<code>T</code>满足是一个函数类型，那么我们返回其函数的返回类型，也就是<code>P</code>；如果不是一个函数类型，就返回<code>never</code></li>
</ul>
<p>此外，<strong>要注意<code>infer</code>声明的变量只能在<code>true</code>分支中使用</strong>。</p>
<h2 id="对使用了函数重载的函数进行类型推断"><a href="#对使用了函数重载的函数进行类型推断" class="headerlink" title="对使用了函数重载的函数进行类型推断"></a><strong>对使用了函数重载的函数进行类型推断</strong></h2><p>函数重载或⽅法重载是使⽤相同名称和不同参数数量或类型创建多个⽅法的⼀种能⼒。一些 <code>JavaScript</code> 函数在调用的时候可以传入不同数量和类型的参数。举个例子。你可以写一个函数，返回一个日期类型 <code>Date</code>，这个函数接收一个时间戳（一个参数）或者一个 月/日/年 的格式 (三个参数)。在 <code>TypeScript</code>中，我们可以通过写重载签名 (<code>overlaod signatures</code>) 说明一个函数的不同调用方法。 我们需要写一些函数签名 (通常两个或者更多)，然后再写函数体的内容：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">timestamp: <span class="built_in">number</span></span>): <span class="title">Date</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">m: <span class="built_in">number</span>, d: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">Date</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">mOrTimestamp: <span class="built_in">number</span>, d?: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(y, mOrTimestamp, d);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(mOrTimestamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d1 = makeDate(<span class="number">12345678</span>);</span><br><span class="line"><span class="keyword">const</span> d2 = makeDate(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> d3 = makeDate(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>对使用了函数重载的函数进行类型推断时，以最后一个签名为准，因为一般这个签名是用来处理所有情况的签名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a = Parameters&lt;<span class="keyword">typeof</span> makeDate&gt;  <span class="comment">//type a = [m: number, d: number, y: number]</span></span><br></pre></td></tr></table></figure>
<h2 id="infer的位置会影响到推断的结果"><a href="#infer的位置会影响到推断的结果" class="headerlink" title="infer的位置会影响到推断的结果"></a><strong>infer的位置会影响到推断的结果</strong></h2><p>这涉及到协变与逆变，具体的区别将在之后的文章中进行讲解，这里只需要知道：协变或逆变与 <code>infer</code> 参数位置有关。在 TypeScript 中，<strong>对象、类、数组和函数的返回值类型</strong>都是协变关系，而<strong>函数的参数类型</strong>是逆变关系，所以 <code>infer</code> 位置如果在函数参数上，就会遵循逆变原则。</p>
<ul>
<li>  <strong>当<code>infer</code>在协变的位置上时，同一类型变量的多个候选类型将会被推断为联合类型，</strong></li>
</ul>
<!---->

<ul>
<li>  <strong>当<code>infer</code>在逆变的位置上时，同一类型变量的多个候选类型将会被推断为交叉类型。</strong></li>
</ul>
<p>看例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>: infer U, <span class="attr">b</span>: infer U &#125; ? U : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> T10 = Foo&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span> &#125;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> T11 = Foo&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span> &#125;&gt;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure>

<p>按照上文的规则，这应该是属于协变，因此<code>T11</code>结果是<code>string | number</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bar&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">b</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span> &#125; ? U : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> T20 = Bar&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">b</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> T21 = Bar&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">b</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;;  <span class="comment">// string &amp; number</span></span><br></pre></td></tr></table></figure>

<p>同样地，<code>x</code>这里既有可能是<code>string</code>,也可能是<code>number</code>,但最终却被推断为交叉类型。这就是因为<code>infer</code>所处的是逆变的位置，即这里是在推断函数的参数类型，导致最终推导为交叉类型。</p>
<h1 id="类型体操实战"><a href="#类型体操实战" class="headerlink" title="类型体操实战"></a>类型体操实战</h1><blockquote>
<p>高质量的类型可以提高项目的可维护性并避免一些潜在的漏洞。【<a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges">type-challenges</a>】旨在让你更好的了解 TS 的类型系统，编写你自己的类型工具，或者只是单纯的享受挑战的乐趣！</p>
</blockquote>
<p>【<a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges">type-challenges</a>】中有各种有关类型操作的小挑战，接下来我将挑选其中与<code>infer</code>有关的一些挑战。</p>
<h3 id="First-of-Array"><a href="#First-of-Array" class="headerlink" title="First of Array"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/README.md">First of Array</a></h3><p>要求：实现一个通用<code>First&lt;T&gt;</code>，它接受一个数组<code>T</code>并返回它的第一个元素的类型。</p>
<p>实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer L, ...infer R] ? L : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>利用了<code>infer</code>声明了<code>L</code>和<code>R</code>进行占位，其中：</p>
<ul>
<li>  <code>infer R</code>： 表示数组第一个元素的占位。</li>
<li>  <code>...infer L</code>: 表示数组剩余元素的占位。</li>
<li>  通过<code>extends</code>判断进入<code>true</code>分支时，返回类型<code>L</code>，否则返回<code>never</code></li>
</ul>
<p>当然，上述实现方式是通过占位实现的，也可以通过索引的方式实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/README.md">Capitalize</a></h3><p>要求：实现 <code>Capitalize&lt;T&gt;</code> 它将字符串的第一个字母转换为大写，其余字母保持原样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> capitalized = Capitalize&lt;<span class="string">&#x27;hello world&#x27;</span>&gt; <span class="comment">// expected to be &#x27;Hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;L&gt;&#125;</span><span class="subst">$&#123;R&#125;</span>`</span>: S</span><br></pre></td></tr></table></figure>

<p>既然有首字母大写，那么相应的首字母小写<code>Uncapatilize</code>的实现也类似：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;L&gt;&#125;</span><span class="subst">$&#123;R&#125;</span>`</span>: S</span><br></pre></td></tr></table></figure>

<p>无论首字母大写还是首字母小写，核心实现还是用<code>infer L</code>去占位，然后对其调用<code>Uppercase</code>或者<code>Lowercase</code></p>
<h3 id="Tuple-to-Union"><a href="#Tuple-to-Union" class="headerlink" title="Tuple to Union"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/README.md">Tuple to Union</a></h3><p>要求：</p>
<p>实现泛型<code>TupleToUnion&lt;T&gt;</code>，返回元组所有值的类型组成的联合类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = TupleToUnion&lt;Arr&gt; <span class="comment">// expected to be &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>]</span><br></pre></td></tr></table></figure>

<p>  <code>T[number]</code>：<strong>它会自动迭代元组的数字型索引，然后将所以元素组合成一个联合类型</strong>。</p>
<p>这种解法应该是比较简单直接的，<code>T[number]</code>的使用比较巧妙，但如果是第一次动手实现这样的类型，比较难想到这种解法。</p>
<p>如果想要用<code>infer</code>实现的话，应该如何操作呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer L, ...infer R] ? L | TupleToUnion&lt;R&gt; : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p><code>L | TupleToUnion&lt;args&gt;</code>：L表示每一次迭代中的第一个元素，它的迭代过程可以用下面伪代码表示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line"><span class="keyword">const</span> L = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> R = [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">&#x27;1&#x27;</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line"><span class="keyword">const</span> L = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="keyword">const</span> R = [<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line"><span class="keyword">const</span> L = <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="keyword">const</span> R = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>说白了就是递归的思想，想通了也不难。</p>
<p>在<a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/tips/infer.html#%E4%B8%80%E4%BA%9B%E7%94%A8%E4%BE%8B">深入理解TypeScritp</a>中看到一种解法，也很巧妙：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;infer R&gt; ? R : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>该实现的前提是：<strong>tuple 类型在一定条件下，是可以赋值给数组类型</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TTuple = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> TArray = <span class="built_in">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Res = TTuple <span class="keyword">extends</span> TArray ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> ResO = TArray <span class="keyword">extends</span> TTuple ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>那么，之后再利用<code>infer</code>类型推导的功能，<code>T extends Array&lt;infer R&gt;</code>进入<code>true</code>分支，就很容易得到想要的结果了。</p>
<h3 id="Union-to-Intersection"><a href="#Union-to-Intersection" class="headerlink" title="Union to Intersection"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00055-hard-union-to-intersection/README.md">Union to Intersection</a></h3><p>要求：将联合类型转换为交叉类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I = Union2Intersection&lt;<span class="string">&#x27;foo&#x27;</span> | <span class="number">42</span> | <span class="literal">true</span>&gt; <span class="comment">// expected to be &#x27;foo&#x27; &amp; 42 &amp; true</span></span><br></pre></td></tr></table></figure>

<p>这个挑战的标签是<code>hard</code>, 还是很有挑战性的。主要涉及到上述注意点中的第三点，</p>
<p>即：<strong>当<code>infer</code>在逆变的位置上时，同一类型变量的多个候选类型将会被推断为交叉类型。</strong></p>
<p>直接给出<code>stackoverflow</code>上的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50374908/transform-union-type-to-intersection-type">解答</a>:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = (U <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">(<span class="params">k: U</span>) =&gt;</span> <span class="built_in">void</span> : <span class="built_in">never</span>) <span class="keyword">extends</span> (<span class="function">(<span class="params">k: infer I</span>) =&gt;</span> <span class="built_in">void</span>) ? I : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>具体实现可以分为以下几个步骤：</p>
<ul>
<li><p>  利用<code>extends</code>分配条件类型语句将联合类型中的每一个处理成<code>(x: U) =&gt; any</code>这样的函数类型</p>
</li>
<li><p>然后利用当<code>infer</code>在逆变的位置上时，同一类型变量的多个候选类型将会被推断为交叉类型，得到想要的结果。</p>
<p>  其中，逆变的过程类似如下：</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> T2 = &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bar&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>; b: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span> &#125; ? U : <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// 处在逆变位置时，推导出来的为交叉类型</span></span><br><span class="line"><span class="keyword">type</span> T21 = Bar&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: T1</span>) =&gt;</span> <span class="built_in">void</span>; b: <span class="function">(<span class="params">x: T2</span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;; <span class="comment">// T1 &amp; T2</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li>
</ul>
<ol>
<li><p>作用：<strong>类型推导</strong>，在类型未推导时进行占位，等到真正推导成功后，它能准确地返回正确的类型</p>
</li>
<li><p>注意点：</p>
</li>
</ol>
<ul>
<li>  <code>infer</code>只能在 extends 条件语句中使用，声明变量只能在true分支中使用</li>
<li>  对使用了函数重载的函数进行类型推断时，以最后一个签名为准，因为一般这个签名是用来处理所有情况的签名。</li>
<li>  当<code>infer</code>在协变的位置上时，同一类型变量的多个候选类型将会被推断为联合类型；当<code>infer</code>在逆变的位置上时，同一类型变量的多个候选类型将会被推断为交叉类型。</li>
</ul>
<p><strong>更多</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7105778922851139598">TypeScript类型操作中的关键字详解（一）：keyof &amp; in</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7106038466139389959">TypeScript类型操作中的关键字详解（二）：extends</a></p>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999441997236797470">精读《Typescript infer 关键字》</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/pull/21496#"><br>Type inference in conditional types</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges">type-challenges</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/06/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">TypeScript类型体操中的关键字详解（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-06 15:32:46" itemprop="dateCreated datePublished" datetime="2022-06-06T15:32:46+08:00">2022-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-07 15:39:16" itemprop="dateModified" datetime="2022-06-07T15:39:16+08:00">2022-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在各种类型操作中，少不了<code>extends</code>关键字的身影，它主要有以下几个作用： 接口继承 类型约束以及条件类型</p>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Player <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="attr">item</span>: <span class="string">&#x27;ball&#x27;</span> | <span class="string">&#x27;swing&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口继承后</span></span><br><span class="line"><span class="comment">// interface Person &#123;</span></span><br><span class="line"><span class="comment">//     name: string;</span></span><br><span class="line"><span class="comment">//     age: number;</span></span><br><span class="line"><span class="comment">//     item: &#x27;ball&#x27; | &#x27;swing&#x27;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>   通常和泛型一起使用，那么具体应该如何使用呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogBark</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Dog</span>&gt;(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">  arg.bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   我们定义类型<code>Dog</code>,它 有一个不返回任何值的<code>bark</code>方法，使用<code>extends</code>关键字进行泛型约束，传入<code>dogBark</code>方法的值必须有<code>bark</code>方法，简单的说<code>extends</code>关键字在这里的作用：作为一个守门员，只让会狗叫的进，管你是不是🐕，只要会狗叫，就可以进；如果不会，请出门右转。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cba3fa3d6e64707afa456a1f792efc7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogA = &#123;</span><br><span class="line">  <span class="attr">weight</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogB  =&#123;</span><br><span class="line">  <span class="attr">weight</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;dogB is barking&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dogBark(dogA)       </span><br><span class="line"><span class="comment">// error !!!</span></span><br><span class="line"><span class="comment">// Argument of type &#x27;&#123; weight: number; age: number; &#125;&#x27; is not assignable to parameter of type &#x27;Dog&#x27;.</span></span><br><span class="line"><span class="comment">// Property &#x27;bark&#x27; is missing in type &#x27;&#123; weight: number; age: number; &#125;&#x27; but required in type &#x27;Dog&#x27;.</span></span><br><span class="line"></span><br><span class="line">dogBark(dogB)      <span class="comment">// success: &quot;dogB is barking&quot; </span></span><br></pre></td></tr></table></figure></p>
<p>在使用<code>extends</code>关键字实现一些类型时，可能会用到如下代码：</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P <span class="keyword">extends</span> keyof T</span><br></pre></td></tr></table></figure>

<p>   表示<code>P</code>的类型是<code>keyof T</code>返回的字面量联合类型，也就是说<code>P</code>原本没限制，是<code>any</code>，限制之后类型变成了<code>keyof T</code>返回的字面量联合类型。</p>
<p>   类似的有使用<code>T extends keyof any</code>对对象类型的属性进行约束,<code>keyof any</code>返回的是<code>string | number | symbol</code>，即这也是属性字段的取值范围。</p>
<p>   再来看这样一个<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4CwAUMqciHALYQBcyGYUoA5gNzFnJzO3kCulAEbR2RAL7FiYAJ4AHFADkqEAPIwAPABUAfMgC8yTQG0A5BWomAusgD0N5NChYodQ3JQmAROYieTyBDgQECwwZGFkPgwIABNkMCxkUBiIAA9492QTTRNiOwz5ZCVqNS0HVMgQGIx8M2UTOj4QAGsQgHcQMV0DYzqLa3yMPgQkDAwAQjz7GUL5KGwQYpQDJdL0eZxdWxsGJhBmIA">例子</a></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NameOf&lt;T&gt; = T[<span class="string">&#x27;name&#x27;</span>] <span class="comment">// error:  Type &#x27;&quot;name&quot;&#x27; cannot be used to index type &#x27;T&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>NameOf</code>类型的作用是取得传入类型<code>T</code>中<code>name</code>属性的值的类型，但这里却报错了。因为传入的泛型<code>T</code>不一定有属性<code>name</code>, 传入的可能是一个没有<code>name</code>属性的对象，也可能是一个字面量类型，访问<code>T</code>可能没有的属性是不安全的，因此会报错，要解决这个问题就需要对泛型<code>T</code>进行约束，确保其一定具有<code>name</code>这个属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NameOf&lt;T <span class="keyword">extends</span> &#123;<span class="string">&#x27;name&#x27;</span>: unknown&#125;&gt; = T[<span class="string">&#x27;name&#x27;</span>] <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">type</span> personName = NameOf&lt;Person&gt;  <span class="comment">//string</span></span><br></pre></td></tr></table></figure>

<h2 id="条件类型-Conditional-Types"><a href="#条件类型-Conditional-Types" class="headerlink" title="条件类型 (Conditional Types )"></a>条件类型 (Conditional Types )</h2><p>  常见表现形式为：</p>
   <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以这样理解：<code>T</code>是<code>U</code>的子类型，那么返回结果是<code>&#39;Y&#39;</code>, 否则是<code>&#39;N&#39;</code>.   类似<code>JS</code>中的三元表达式，其工作原理是类似的，例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> res1 = <span class="literal">true</span> <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="literal">true</span> : <span class="literal">false</span>                  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> res2 = <span class="string">&#x27;name&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;name&#x27;</span>|<span class="string">&#x27;age&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>           <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> res3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span>; &#125; ? <span class="literal">true</span> : <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> res4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; ? <span class="literal">true</span> : <span class="literal">false</span>       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>   要注意：</p>
<ul>
<li>  <code>extends</code>在条件类型中的作用和类型约束中的作用不一样</li>
<li>  条件类型只支持在<code>type</code>中使用</li>
</ul>
<p>此外，**<code>extends</code>作为条件类型时也是可以嵌套的**，就像<code>if</code>语句一样。<br>   <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeName&lt;T&gt; =</span><br><span class="line"> T <span class="keyword">extends</span> <span class="built_in">string</span>    ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line"> T <span class="keyword">extends</span> <span class="built_in">number</span>    ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line"> T <span class="keyword">extends</span> <span class="built_in">boolean</span>   ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line"> T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line"> T <span class="keyword">extends</span> <span class="built_in">Function</span>  ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line"> <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> T0 = TypeName&lt;<span class="built_in">string</span>&gt;;  <span class="comment">// &quot;string&quot;</span></span><br><span class="line"> <span class="keyword">type</span> T1 = TypeName&lt;<span class="string">&quot;a&quot;</span>&gt;;     <span class="comment">// &quot;string&quot;</span></span><br><span class="line"> <span class="keyword">type</span> T2 = TypeName&lt;<span class="literal">true</span>&gt;;    <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"> <span class="keyword">type</span> T3 = TypeName&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;;  <span class="comment">// &quot;function&quot;</span></span><br><span class="line"> <span class="keyword">type</span> T4 = TypeName&lt;<span class="built_in">string</span>[]&gt;;    <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   <hr/></p>
<p>   再来看如下代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A1 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">//  type A1 = number</span></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; <span class="comment">// ?   type A2 = string | number </span></span><br></pre></td></tr></table></figure>

<p>   <code>A2</code>结果为什么不是<code>number</code>呢？实际发生的操作类似如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; </span><br><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="string">&#x27;x&#x27;</span>&gt;  | P&lt;<span class="string">&#x27;y&#x27;</span>&gt;</span><br><span class="line"><span class="keyword">type</span> A2 = (<span class="string">&#x27;x&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>) | (<span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>)</span><br><span class="line"><span class="keyword">type</span> A2 = <span class="built_in">string</span> | <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<p>这叫<strong>分配条件类型（<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types="><code>Distributive Conditional Types</code></a>）</strong></p>
<p>当<code>T</code>为泛型时，且传入该泛型的是一个联合类型，那么该联合类型中的每一个类型都要进行上述操作，最终返回上述操作结果组成的新联合类型。换句话说，这里的<code>分配</code>是指将上述提到的”三元表达式”操作应用于联合类型中的每个成员。</p>
<p><strong>要注意的是：</strong></p>
<p><strong>1. <code>extends</code>关键字左侧的是一个泛型，且传入泛型的必须是联合类型，其他类型如交叉类型是没有<code>分配</code>效果的。</strong></p>
<p>如果左侧不是泛型，直接传入一个联合类型，是没有<code>分配</code>效果的，只是一个简单的条件判断。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> A1 = <span class="string">&#x27;x&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> A2 = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// number</span></span><br><span class="line"><span class="comment">// 如果分配生效的话，结果应该是 string | number</span></span><br></pre></td></tr></table></figure>

<p><strong>2. <code>分配</code>操作只有在检查的类型是<code>naked type parameter</code>时才生效。</strong></p>
<p>那么是什么是<code>naked type parameter</code>呢？直接翻译过来怪怪的，参数是<code>裸</code>的？<br>我的理解是没有对传进来的泛型参数进行一些额外操作，那么就符合<code>naked type parameter</code>的要求。</p>
<p>看一下以下的例子，更容易理解。这也是<code>stackoverflow</code>上一个高赞回答的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/51651499/typescript-what-is-a-naked-type-parameter">例子</a>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NakedUsage&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span></span><br><span class="line"><span class="keyword">type</span> WrappedUsage&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">boolean</span>] ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>; <span class="comment">// wrapped in a tuple,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Distributed = NakedUsage&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span> &gt; <span class="comment">// = NakedUsage&lt;number&gt; | NakedUsage&lt;boolean&gt; =  &quot;NO&quot; | &quot;YES&quot; </span></span><br><span class="line"><span class="keyword">type</span> NotDistributed = WrappedUsage&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span> &gt; <span class="comment">// &quot;NO&quot;    </span></span><br><span class="line"><span class="keyword">type</span> NotDistributed2 = WrappedUsage&lt;<span class="built_in">boolean</span> &gt; <span class="comment">// &quot;YES&quot;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>WrappedUsage</code>对传入的泛型参数进行了操作，不属于<code>naked type parameter</code>，因此不会进行<code>分配</code>操作。</p>
<h1 id="类型操作实战"><a href="#类型操作实战" class="headerlink" title="类型操作实战"></a>类型操作实战</h1><h2 id="Pick-amp-Record"><a href="#Pick-amp-Record" class="headerlink" title="Pick &amp; Record"></a>Pick &amp; Record</h2><p>与<code>extends</code>类型约束特性相关的工具类型有<code>Pick</code>和<code>Record</code></p>
<p><strong>Pick</strong></p>
<p><code>Pick</code>表示从一个类型中选取指定的几个字段组合成一个新的类型，用法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PickResult = Pick&lt;Person, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;address&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// &#123; name: string; address: string; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先进行了类型限定，<code>K</code>一定是<code>T</code>的子集，然后用<code>in</code>遍历<code>K</code>中的每个属性, T[P]是属性对应的值。</p>
<p><strong>Record</strong></p>
<p><code>Record&lt;K, T&gt;</code>用来将<code>K</code>的每一个键(<code>k</code>)指定为<code>T</code>类型，这样由多个<code>k/T</code>组合成了一个新的类型，用法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keys = <span class="string">&#x27;Cat&#x27;</span>|<span class="string">&#x27;Dot&#x27;</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RecordResult = Record&lt;keys, Animal&gt;</span><br><span class="line"><span class="comment">// result: </span></span><br><span class="line"><span class="comment">// type RecordResult = &#123;</span></span><br><span class="line"><span class="comment">//     Cat: Animal;</span></span><br><span class="line"><span class="comment">//     Dot: Animal;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>keyof any</code>是什么鬼？鼠标放上去看看就知道了</p>
<p>因此，<code>keyof any</code>即<code>string | number | symbol</code>，先对键的取值范围进行了限定，只能是这三者中的一个。</p>
<h2 id="Exclude-amp-Extract-amp-NonNullable"><a href="#Exclude-amp-Extract-amp-NonNullable" class="headerlink" title="Exclude &amp; Extract &amp; NonNullable"></a>Exclude &amp; Extract &amp; NonNullable</h2><p>与<code>extends</code>条件类型特性相关的工具类型又有哪些呢？</p>
<p>先看着两个：<code>Exclude</code>和<code>Extract</code></p>
<p><code>Exclude&lt;T, U&gt;</code>: 排除<code>T</code>中属于<code>U</code>的部分</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb69201dbdb47c5b42c4cd6518aa888~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><code>Extract&lt;T, U&gt;</code>： 提取<code>T</code>中属于<code>U</code>的部分，即二者交集</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e339f4ecf7f1482fada83c125f347d03~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>使用方法</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExcludeResult = Exclude&lt;<span class="string">&#x27;name&#x27;</span>|<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>|<span class="string">&#x27;address&#x27;</span>&gt;</span><br><span class="line"><span class="comment">//type ExcludeResult = &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExcludeResult = Extract&lt;<span class="string">&#x27;name&#x27;</span>|<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>|<span class="string">&#x27;address&#x27;</span>&gt;</span><br><span class="line"><span class="comment">//type ExcludeResult = &quot;sex&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>实现思路不再赘述，见前文<code>extends</code>分配条件类型的原理</p>
<p><code>NonNullable</code>工具类型可以从目标类型中排除<code>null</code>和<code>undefined</code>，和<code>Exclude</code>相比，它将<code>U</code>限定的更具体。</p>
<p>实现也很简单：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="string">&#x27;dog&#x27;</span> | <span class="built_in">Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type nonNullable&lt;T&gt; = Exclude&lt;T , undefined | null&gt;</span></span><br><span class="line"><span class="keyword">type</span> nonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> res = nonNullable&lt;A&gt;   <span class="comment">// type res = Function | &quot;dog&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><p>根据已经实现的<code>Exclude</code>类型，可以实现<code>Omit</code>类型，<code>Omit&lt;T, K&gt;</code>:删除<code>T</code>中指定的字段，用法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OmitResult = Omit&lt;Person, <span class="string">&#x27;address&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 结果：&#123; name？: string; age: number; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>首先，删除指定字段，字段类型限定在 <code>string | symbol number</code>中，然后用<code>Exclude</code>从<code>T</code>的属性所组成的字面量联合类型中移除指定字段，形成新的联合类型；最后利用<code>Pick</code>选取指定字段生成新的类型</p>
<h2 id="AppendToObject"><a href="#AppendToObject" class="headerlink" title="AppendToObject"></a>AppendToObject</h2><p><code>AppendToObject</code>的作用是向指定对象中添加一个属性, 同时指定属性值的类型。如果该属性字段之前就存在，新增的字段会被忽略。</p>
<p>注：该类型并不是内置工具类型</p>
<p><strong>使用方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// expected to be &#123; id: &#x27;1&#x27;, value: 4 &#125;</span></span><br><span class="line"><span class="keyword">type</span> Result = AppendToObject&lt;Test, <span class="string">&#x27;value&#x27;</span>, <span class="number">4</span>&gt; </span><br><span class="line"><span class="comment">// 结果：&#123; id: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = AppendToObject&lt;&#123; <span class="attr">id</span>: <span class="built_in">number</span>; &#125;, <span class="string">&#x27;name&#x27;</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>实现方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendToObject&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, V&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T | K]: P <span class="keyword">extends</span> keyof T ? T[P] : V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先, 需要遍历的所有属性包含<code>T</code>中的属性字段和新增的字段<code>K</code>,即<code>keyof T | K</code>,然后使用<code>in</code>关键字进行遍历操作，对遍历到的每个属性字段使用<code>extends</code>进行判断，如果遍历到的字段<code>P</code>是原本<code>T</code>中就存在的属性字段，判断为<code>true</code>,返回<code>T[p]</code>;否则为<code>false</code>,说明该属性字段之前并不存在，返回新增字段对应的类型<code>V</code>。</p>
<h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/README.md">Merge</a></h2><p><code>Merge</code>将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。</p>
<p><strong>使用方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coo = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result = Merge&lt;foo,coo&gt;; <span class="comment">// expected to be &#123;name: string, age: number, sex: string&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>实现方式</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Merge&lt;F, S&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span>  keyof F | keyof S]: P <span class="keyword">extends</span> keyof S ? S[P] : P <span class="keyword">extends</span> keyof F ? F[P] : <span class="built_in">never</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了两次<code>extends</code>, 写成下方这种形式可能更清楚一些：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Merge&lt;F, S&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span>  keyof F | keyof S]: </span><br><span class="line">    P <span class="keyword">extends</span> keyof S </span><br><span class="line">      ? S[P] </span><br><span class="line">      : (P <span class="keyword">extends</span> keyof F ? F[P] : <span class="built_in">never</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>AppendToObject</code>一样，首先用<code>in</code>关键字遍历所有的属性字段（<code>keyof F | keyof S</code>）, 在此过程中对每一字段进行相应判断，因为<code>S</code>中的对应的字段会对<code>F</code>中相同字段进行覆盖，因此先判断该字段是否属于<code>S</code>，然后再判断该字段是否属于<code>P</code>。</p>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html">ts handbook</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904066485583885">TypeScript 的 extends 条件类型</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges">type challenges</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/05/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">TypeScript类型体操中的关键字详解（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 15:31:54" itemprop="dateCreated datePublished" datetime="2022-06-05T15:31:54+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-07 15:39:11" itemprop="dateModified" datetime="2022-06-07T15:39:11+08:00">2022-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在<code>TypeScript</code>类型操作中<code>typeof</code>和<code>in</code>经常放在一起使用，使用频率也很高，因此将这两个关键字放在一起介绍。</p>
<h1 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>keyof</code>操作符接受一个对象类型作为参数，返回该对象属性名组成的<strong>字面量联合类型</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>;  &#125;;</span><br><span class="line"><span class="keyword">type</span> D = keyof Dog; <span class="comment">//type D = &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure>

<p>在一些高级类型中经常会用到<code>keyof any</code>, 这又是什么鬼？鼠标放上去看看就知道了<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be56867c675481dbe8711edc957205d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以看到<code>keyof any</code> 返回的是一个联合类型：<code>string | number | symbol</code>，结合前文说到<code>keyof</code>是为了取得对象的<code>key</code>值组成的联合类型，那么<code>key</code>值有可能是什么类型呢？自然就是<code>string | number | symbol</code>。</p>
<p>该关键字一般会和<code>extends</code>关键字结合使用，对对象属性的类型做限定，比如<code>K extends keyof any</code>就代表K的类型一定是<code>keyof any</code>所返回的联合类型的子类，如果输入不符合限定，那么自然也就不能作为对象的属性，类型系统就会报错。</p>
<p>因此，<code>keyof any</code> 表示了对象<code>key</code>值可能的取值类型。这一点在本文之后的一些类型实现中也会用到。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><strong>遇到索引签名时，<code>typeof</code>会直接返回其类型</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog = &#123;  [y:<span class="built_in">number</span>]: <span class="built_in">number</span>  &#125;;</span><br><span class="line"><span class="keyword">type</span> dog = keyof Dog;  <span class="comment">//type dog = number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Doggy = &#123;  [y:<span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> doggy = keyof Doggy; <span class="comment">//type doggy = string | number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Doggy = &#123;  [y:<span class="built_in">string</span>]: unknown, [x:<span class="built_in">number</span>]: <span class="built_in">boolean</span>&#125;;</span><br><span class="line"><span class="keyword">type</span> doggy = keyof Doggy; <span class="comment">//type doggy = string | number</span></span><br></pre></td></tr></table></figure>

<p>可以看到索引类型为<code>number</code>时，<code>keyof</code> 返回的类型是<code>string | number</code>, 这是因为<code>JavaScript</code>的对象属性会默认转换为字符串。</p>
<h1 id="in"><a href="#in" class="headerlink" title="in"></a>in</h1><p><code>in</code>的右侧一般会跟一个联合类型，使用<code>in</code>操作符可以对该联合类型进行迭代。<br>其作用类似<code>JS</code>中的<code>for...in</code>或者<code>for...of</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animals = <span class="string">&#x27;pig&#x27;</span> | <span class="string">&#x27;cat&#x27;</span> | <span class="string">&#x27;dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animals = &#123;</span><br><span class="line">    [key <span class="keyword">in</span> Animals]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type animals = &#123;</span></span><br><span class="line"><span class="comment">//     pig: string; //第一次迭代</span></span><br><span class="line"><span class="comment">//     cat: string; //第二次迭代</span></span><br><span class="line"><span class="comment">//     dog: string; //第三次迭代</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="类型操作实战"><a href="#类型操作实战" class="headerlink" title="类型操作实战"></a>类型操作实战</h1><h2 id="Partial-amp-Required"><a href="#Partial-amp-Required" class="headerlink" title="Partial &amp; Required"></a>Partial &amp; Required</h2><p><code>Partial</code>：将某个类型里的属性全部变为可选项</p>
<p>思路是通过泛型传入待处理类型，先用<code>keyof</code>取到所给类型所有属性组成的字面量联合类型，然后使用<code>in</code>进行遍历，同时结合 <code>?</code>操作符，将每个属性变成可选的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>[P in keyof T]</code>这段代码表示遍历<code>T</code>中的每一个属性,那么<code>T[P]</code>就是每个属性所对应的值，可以简单理解为前者取的是键<code>key</code>，后者取的是值<code>value</code></p>
<p><code>Required</code>：和<code>Partial</code>的作用相反，是为了将某个类型里的属性全部变为必选的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  a?: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> obj: Props = &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;; <span class="comment">// b是可选的，因此缺少这个属性也可以</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> obj2: Required&lt;Props&gt; = &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;;  <span class="comment">// 通过Required将属性变为必选的，等号右边对象缺少这个属性，因此赋值失败</span></span><br><span class="line"><span class="comment">//Property &#x27;b&#x27; is missing in type &#x27;&#123; a: number; &#125;&#x27; but required in type &#x27;Required&lt;Props&gt;&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>实现思路和前面相似</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文对应的<code>-？</code>代表着去掉可选，与之对应的还有<code>+？</code>，两者正好相反</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/06/promise%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/06/promise%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">promise解决了什么问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-06 16:17:18" itemprop="dateCreated datePublished" datetime="2022-05-06T16:17:18+08:00">2022-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 14:21:13" itemprop="dateModified" datetime="2022-05-16T14:21:13+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="promise解决了什么问题？"><a href="#promise解决了什么问题？" class="headerlink" title="promise解决了什么问题？"></a>promise解决了什么问题？</h3><p>主要是回调嵌套和控制反转</p>
<p><strong>回调嵌套</strong></p>
<p>嵌套和缩进只是格式层面的问题，深层次问题是代码难以复用、堆栈信息断开、引用外层变量</p>
<ul>
<li><p>代码难以复用</p>
<blockquote>
<p>回调中引用了外层变量，提取出来后需要进行相应修改</p>
</blockquote>
</li>
<li><p>堆栈信息断开</p>
<blockquote>
<p>异步回调函数执行时将回调函数放入任务队列中，代码继续执行，直到主线程完成，然后才会从任务队列中选择已经完成的任务放入执行栈中，如果回调报错，无法获取调用该异步操作时的栈中的信息，不容易判定哪里出现了错误。</p>
</blockquote>
</li>
<li><p>借助外层变量</p>
<blockquote>
<p>多个异步计算同时进行，由于无法预期完成顺序，必须借助外层作用域的变量，可能被其它同一作用域的函数访问并且修改，容易造成误操作。</p>
</blockquote>
</li>
</ul>
<p><strong>控制反转</strong></p>
<p>使用第三方api，回调函数的执行次数、是否执行、执行时机都取决于第三方库的实现</p>
<ol>
<li>回调函数执行多次      ===&gt;  promise只能resolve一次</li>
<li>回调函数没有执行   ===&gt; 使用Promise.race判断</li>
<li>回调函数有时同步执行有时异步执行  ===&gt; promise总是异步的</li>
</ol>
<h4 id="async-await的问题"><a href="#async-await的问题" class="headerlink" title="async  await的问题"></a>async  await的问题</h4><p><strong>场景一：组合多个promsie</strong></p>
<p>await关键字是串行的，想要同时获取多个promise的结果，需要用promise的api进行处理，比如promise.all</p>
<p><strong>场景二：存储promsie的值</strong></p>
<p>async/await 是语法，不是值，因此它不能被存储和传递。而 promise 对象，<strong>可以存储在内存里，可以作为参数在函数中传递。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2f69064fa2a4c2cba1655b7318515fa~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>建立url到promise映射，通过async/await语法隐藏了promise对象，顶多建立url到result的缓存，但是当页面上发出get请求，结果未抵达，但是又触发了多个相同请求的话就无法命中result缓存，如果缓存的是promise的对象，就可以将同一个promise返回，利用promise对象可以多次调用then方法的特性，让所有相同的get请求获得同一个异步请求结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/promise%E7%9A%84%E4%B8%80%E4%BA%9Bapi%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/promise%E7%9A%84%E4%B8%80%E4%BA%9Bapi%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">promise的一些api的应用场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 17:20:01" itemprop="dateCreated datePublished" datetime="2022-05-05T17:20:01+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 14:20:51" itemprop="dateModified" datetime="2022-05-16T14:20:51+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>所有的 promsie 都resolve时， 返回存储结果的数组，如果其中一个promise   reject，那么会忽略剩余promise 的结果，哪怕其他promise都resolved，剩下的最后一个promise  rejected, 其error会变成整个 <code>Promise.all</code>的结果, 已经resolved 的结果会被忽略。</p>
<p><strong>应用场景：</strong></p>
<p><strong>合并请求结果</strong></p>
<blockquote>
<p>具体描述：一个页面，有多个请求，我们需求所有的请求都返回数据后再一起处理渲染</p>
</blockquote>
<p>不需要为每个请求都设置loading状态，从请求开始到请求结束，只需要设置一个loading状态</p>
<p>可能的场景：点击按钮，跳出一个对话框，对话框中显示两部分数据，来自两个不同的api接口，当这两部分数据都从接口获取到的时候，才让这个 <code>数据加载中</code>状态消失。让用户看到这两部分的数据。</p>
<p><strong>合并请求结果并处理错误</strong></p>
<blockquote>
<p><strong>单独处理一个请求的数据渲染和错误处理逻辑</strong>，有多个请求</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// loading.show()</span></span><br><span class="line">    <span class="built_in">Promise</span>.all([</span><br><span class="line">        getBannerList().catch(<span class="function"><span class="params">err</span>=&gt;</span>err),</span><br><span class="line">        getStoreList().catch(<span class="function"><span class="params">err</span>=&gt;</span>err),</span><br><span class="line">        getCategoryList().catch(<span class="function"><span class="params">err</span>=&gt;</span>err)</span><br><span class="line">    ]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// [&quot;获取轮播图数据失败啦&quot;, &quot;店铺数据&quot;, &quot;分类数据&quot;]</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] == <span class="string">&#x27;轮播图数据&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//渲染</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取 轮播图数据 失败的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">1</span>] == <span class="string">&#x27;店铺数据&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//渲染</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取 店铺列表数据 失败的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">2</span>] == <span class="string">&#x27;分类数据&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//渲染</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//获取 分类列表数据 失败的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// loading.hide()</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里考虑使用Promise.allSettled也可以。</p>
<p><strong>验证多个请求结果是否都满足条件</strong></p>
<blockquote>
<p>具体描述：表单的输入内容安全验证，多个字段调用的是同一个内容安全校验接口，只有所有都检验通过够才能够正常提交。</p>
</blockquote>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>请求超时提示：<strong>点击按钮发请求，当后端的接口超过一定时间，假设超过三秒，没有返回结果，我们就提示用户请求超时</strong>，例如请求一张图片时超时提示</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/04/%E4%BD%BF%E7%94%A8transform%E5%B1%9E%E6%80%A7%E8%A7%A3%E5%86%B31px%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/%E4%BD%BF%E7%94%A8transform%E5%B1%9E%E6%80%A7%E8%A7%A3%E5%86%B31px%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">使用transform属性解决1px问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-04 14:14:59" itemprop="dateCreated datePublished" datetime="2022-05-04T14:14:59+08:00">2022-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 14:16:04" itemprop="dateModified" datetime="2022-05-16T14:16:04+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p><code>px</code>是一个相对单位，并不是说<code>1px</code>就一定等于1个物理像素，设备像素比不同，<code>1px</code>对应的物理像素数量不同。也就是说在不同设备、不同分辨率的情况下，<code>1px</code>所代表的物理像素数量不一样，因此<code>1px</code>在屏幕上显示的宽度也不一样。</p>
<h2 id="设备像素、css像素、设备独立像素、设备像素比"><a href="#设备像素、css像素、设备独立像素、设备像素比" class="headerlink" title="设备像素、css像素、设备独立像素、设备像素比"></a>设备像素、css像素、设备独立像素、设备像素比</h2><p><strong>设备像素</strong>：设备像素又称物理像素，是设备能够控制显示的最小物理单位</p>
<p><strong>css像素</strong>：px是一个相对单位，相对的是设备像素（device pixel）一般情况，页面缩放比为1，1个CSS像素等于1个设备独立像素</p>
<p><strong>设备独立像素</strong>：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素，而至于1个虚拟像素究竟对应几个物理像素，就设计设备像素比（device pixel ratio）</p>
<p><strong>设备像素比</strong>：<code>DPR = 设备像素/设备独立像素</code></p>
<p>当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素</p>
<p>当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素</p>
<p>当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素</p>
<blockquote>
<p>设备像素比可通过<code>window.devicePixelRatio</code>查询</p>
</blockquote>
<h2 id="实现一条1px的线"><a href="#实现一条1px的线" class="headerlink" title="实现一条1px的线"></a>实现一条1px的线</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="selector-class">.A</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="selector-class">.A</span> &#123;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-ration</span>: <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-class">.A</span> &#123;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.333</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>transform</code>中的<code>scale</code>字段能够对元素进行缩放，当<code>dpr=2</code>时，（2 * 2）个物理像素对应1个设备独立像素，因此<code>scale(0.5, 0.5)</code>代表将<code>1px</code>缩放为原本的0.5倍，这样我们就得到了和<code>dpr=1</code>的设备上显示一样宽的<code>1px</code></p>
<p>通过<code>媒体查询</code>针对不同dpr进行不同的缩放，保持各设备显示的一致性</p>
<h2 id="实现一像素的边框"><a href="#实现一像素的边框" class="headerlink" title="实现一像素的边框"></a>实现一像素的边框</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;target&quot;</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#bfbfbf</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-class">.target</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    -webkit-<span class="attribute">transform-origin</span>: top left;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-class">.target</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.33</span>,<span class="number">0.333</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.333</span>,<span class="number">0.333</span>);</span><br><span class="line">    -webkit-<span class="attribute">transform-origin</span>: top left;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>transform-origin</code></strong> CSS属性用于更改一个元素变形的原点。默认原点是元素旋转中心。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/02/%E7%90%86%E6%B8%85TypeScript%E4%B8%ADinterface%E4%B8%8Etype%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/02/%E7%90%86%E6%B8%85TypeScript%E4%B8%ADinterface%E4%B8%8Etype%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">理清TypeScript中interface与type的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-02 14:07:49" itemprop="dateCreated datePublished" datetime="2022-05-02T14:07:49+08:00">2022-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 14:09:11" itemprop="dateModified" datetime="2022-05-16T14:09:11+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h2><blockquote>
<p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an <code>interface</code> are available in <code>type</code>, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p>
</blockquote>
<p>从上面这段话中我们可以得知：</p>
<ul>
<li>  几乎<code>interface</code>的所有特性都可以用<code>type</code>实现</li>
<li>  <code>interface</code>可以添加新的属性，是可扩展的</li>
</ul>
<h2 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h2><p>针对第一点，参考官方对<code>interface</code>与<code>type</code>的描述：</p>
<blockquote>
<ul>
<li>  Interfaces are basically a way to describe data shapes, for example, an object.</li>
<li>  Type is a definition of a type of data, for example, a union, primitive, intersection, tuple, or any other type.</li>
</ul>
</blockquote>
<p><code>interface</code>用来描述数据的形状（data shapes）</p>
<blockquote>
<p>至于什么是数据的形状呢？ 例如二叉树中数据以分层的形式排布，每个元素最多由两个子元素；在链表中，数据以链式存储，顺序布局，这便是<code>data shapes</code>，结合数据本身，以及保留<code>data shapes</code>的相关操作（对于链表来说就是对链表节点的添加、删除等，不破坏原有结构），这三者就组成了数据结构。</p>
</blockquote>
<p><code>type</code>是数据类型的定义，如<strong>联合类型（A |Ｂ）</strong> 、<strong>基本类型</strong>、<strong>交叉类型（Ａ＆B</strong>）、<strong>元组</strong>等，此外type 语句中还可以使用 <code>typeof</code>获取实例的类型进行赋值。</p>
<p>简而言之，**<code>interface</code>右边必须是 <code>data shapes</code>, 而<code>type</code>右边可以是任何类型。**</p>
<blockquote>
<p>开头提到<code>interface</code>是可扩展的的，也是得益于声明合并，而<code>type</code>虽然通过<code>extends</code>可以达到类似的效果，但谈不上可扩展。官方描述中也提到:</p>
<p><code>the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</code></p>
</blockquote>
<h2 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h2><p>针对第二点，<code>interface</code>支持声明合并（<code>declaration merging</code>），<code>type alias</code>不支持。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并为:interface Person &#123; name: string age: number&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// error: Duplicate identifier &#x27;User&#x27;.</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要有两点区别：</p>
<ol>
<li> <code>interface</code>右边只能是<code>data shapes</code>,而<code>type</code>右边涵盖的范围更大，还可以是<strong>联合类型（A |Ｂ）</strong> 、<strong>基本类型</strong>、<strong>交叉类型（Ａ＆B</strong>）、<strong>元组</strong>等，也可以使用<code>typeof</code></li>
<li> <code>interface</code>支持声明合并，<code>type</code>不支持声明合并。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces">TS Handbook</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/TS%E4%B8%ADnever%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/TS%E4%B8%ADnever%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/" class="post-title-link" itemprop="url">TS中never类型有什么作用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 14:00:00" itemprop="dateCreated datePublished" datetime="2022-05-01T14:00:00+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 14:06:07" itemprop="dateModified" datetime="2022-05-16T14:06:07+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="bottom-type"><a href="#bottom-type" class="headerlink" title="bottom type"></a>bottom type</h2><p>首先, <code>never</code>是一个<code>bottom type</code>，这如何体现呢？</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd87a8db7f54de889e3ef83dd13e46f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><strong>注</strong>：✅表示 <code>strictNullChecks</code> 为<strong>false</strong>时的情况</p>
<p><code>never</code>和<code>unknown</code>朝着两个相反的方向行进，所有的类型都可以赋值给<code>unknown</code>, <code>never</code>可以赋值给任何类型；<code>unknown</code>不能赋值给除any和自身之外的任何类型，除<code>never</code>本身外，任何类型都不能赋值给<code>never</code></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p><strong>用于从来不会返回值的函数</strong></p>
<p> 这可能有两种情况，一是函数中可能死循环</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>):<span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I always does something and never ends.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另外一种情况就是这个函数总是会抛出一个错误，因此也总是没有返回值</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>):<span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>穷尽检查（Exhaustiveness checking）</strong></p>
<p> 对于一个联合类型，将其类型收窄为<code>never</code></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">interface Bar &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">type All = Foo | Bar</span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleValue</span>(<span class="params">val: All</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (val.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">      <span class="comment">// 这里 val 被收窄为 Foo</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;bar&#x27;</span>:</span><br><span class="line">      <span class="comment">// val 在这里是 Bar</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="comment">// val 在这里是 never</span></span><br><span class="line">      <span class="keyword">const</span> exhaustiveCheck: never = val</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过case 对可能的类型进行了相应处理，因此<code>default</code>处<code>val</code>的类型是<code>never</code>，这也体现了<code>never</code>是一个底层类型：<code>never</code>只能赋值给<code>never</code>。如果之后联合类型<code>All</code>中添加了新的类型，但是在代码中忘记进行相应处理，那么就能提前暴露处错误，提醒开发者进行处理。</p>
<h2 id="never和void的区别"><a href="#never和void的区别" class="headerlink" title="never和void的区别"></a>never和void的区别</h2><ol>
<li><p>从赋值的角度来看，<code>undefined</code>可以赋值给<code>void</code>类型的变量，除了<code>never</code>本身，任何值都不能赋值给<code>never</code>类型，也就是说<code>never</code>意味着没有任何值。</p>
<blockquote>
<p>注：<strong>strictNullChecks</strong>为<code>false</code>时，<code>null</code>类型也是可以赋值给<code>void</code>的</p>
</blockquote>
</li>
<li><p><code>void</code> 表示一个函数并不会返回任何值，当函数并没有任何返回值，或者返回不了明确的值的时候，就应该用这种类型。</p>
<p> <code>never</code>表示一个函数从来不返回值，可能这个函数处于死循环，一直在运行，也可能这个函数运行过程中报错；<code>never</code>只能赋值给<code>never</code>，可以利用这个特性进行<strong>穷尽检查（Exhaustiveness checking）</strong> 。</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>注：</strong></p>
<p>当基于上下文的推导，返回类型为<code>void</code>时，不会强制返回函数一定不能返回内容，也就是说当这样一个类型<code>(type vf = () =&gt; void)</code>被应用时，也是可以返回值的，只不过返回的值会被忽略。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = f1() <span class="comment">//let a: void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f2: voidFunc = <span class="function">() =&gt;</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = f2()  <span class="comment">//let b: void</span></span><br><span class="line"><span class="keyword">const</span> f3: voidFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = f3() <span class="comment">//let c: void</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>a</code> <code>b</code> <code>c</code>的类型都是<code>void</code></p>
<p>但当一个函数字面量定义返回一个 <code>void</code> 类型，函数是一定不能返回任何东西的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//Type &#x27;true&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//Type &#x27;true&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html">ts handbook</a></p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks=">strictNullChecks</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/TS%E4%B8%ADany%E5%92%8Cunknown%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/TS%E4%B8%ADany%E5%92%8Cunknown%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">TS中any和unknown有什么区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-30 13:59:02" itemprop="dateCreated datePublished" datetime="2022-04-30T13:59:02+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 14:02:05" itemprop="dateModified" datetime="2022-05-16T14:02:05+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>首先是二者的相同点：<code>unknown</code>和<code>any</code>都是顶层类型，也就是所有类型都可以赋值给<code>unknown</code>和<code>any</code></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>不同点在于<strong>与<code>any</code>相比，<code>unknown</code>是更符合类型安全原则</strong>的，使用<code>any</code>就意味着放弃了类型安全检查，此时你可以对一个<code>any</code>类型的的变量进行任何操作，但如果这个变量是<code>unknown</code>，你不能直接对它进行操作，因为<code>unknown</code>此刻类型是未知的，直接操作可能会出错，需要<code>unknown</code>进行<strong>类型收窄</strong>。</p>
<blockquote>
<p>传统功夫是讲究<code>化劲儿</code>的，<code>any</code>就是这样一股<code>化劲儿</code>，哪里不通怼哪里，<code>化劲儿</code>练到最后就可以将<code>anyscript</code>修炼到大成，也就是纯正的<code>Javascript</code>，即没有类型检查的阶段！</p>
</blockquote>
<p>注意观察下面的例子:</p>
<p><strong>使用 any 跳过了类型检查，不会报错；</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span>(<span class="params">callback: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同样是顶层类型，unknown 会有类型检查</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span>(<span class="params">callback: unknown</span>) </span>&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125; <span class="comment">//(parameter) callback: unknown Object is of type &#x27;unknown&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>虽然上述例子中，使用<code>any</code>时不会爆出类型错误，但是最终运行代码时还是可能会报错，比如运行 <code>sayMyName(1)</code>; 但 使用<code>unknown</code>时，同样的代码，TS为我们指出了潜在的错误，这也是<code>TypeScript</code>的初衷，因此说：**<code>与</code>any<code>相比，</code>unknown<code>是更符合类型安全原则的</code>**。</p>
<p>对使用<code>unknown</code>的情形进行类型收窄：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span>(<span class="params">callback: unknown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将unknown收窄到特定类型</strong>，就不会报错了。</p>
<p>也可以使用<strong>类型断言</strong>达到类似效果</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res: unknown = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> = res <span class="keyword">as</span> <span class="built_in">string</span> <span class="comment">//通过类型检查，但运行报错</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = res <span class="keyword">as</span> <span class="built_in">number</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleLowerCase()) </span><br><span class="line"><span class="comment">// [ERR]: a.toLocaleLowerCase is not a function </span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/%E4%BD%A0%E7%9F%A5%E9%81%93Canvas%E4%B8%8ESvg%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="martisss">
      <meta itemprop="description" content="孩子，快逃！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Martisss's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E4%BD%A0%E7%9F%A5%E9%81%93Canvas%E4%B8%8ESvg%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/" class="post-title-link" itemprop="url">你知道Canvas与Svg之间的区别吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 11:26:35" itemprop="dateCreated datePublished" datetime="2022-04-06T11:26:35+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-09 11:29:52" itemprop="dateModified" datetime="2022-04-09T11:29:52+08:00">2022-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><p><strong>可缩放矢量图形</strong>（<strong>Scalable Vector Graphics，SVG</strong>），是一种用于描述二维的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2">矢量图形</a>，基于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/XML/XML_Introduction">XML</a> 的标记语言, 这意味着可以使用任何文本编辑器(如记事本)创建和编辑<code>SVG</code>图像。</p>
<p>与<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/jpeg">JPEG</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/PNG">PNG</a>这种传统的点阵图像模式不同，SVG格式提供的是矢量图，这意味着它的图像能够被<strong>无限放大而不失真或降低质量</strong>，并且可以方便地修改内容。</p>
<p><code>HTML</code> <code>&lt;svg&gt;</code>元素是<code>svg</code>图形的容器。</p>
<hr/>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://jsbin.com/yejohebuvo/2/edit?html,console,output=">svg demo</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;svgelem&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;greencircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;60&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;60&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#1E81FF&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a84cb8161344125a65d9a5243c45d9c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><p><code>&lt;canvas&gt;</code>本身只是相当于一块画布，不具有绘图能力，必须通过脚本(通常是JavaScript)动态地绘制图形，脚本充当画笔的角色。元素只是图形的容器, 必须使用脚本来实际绘制图形。Canvas有几种绘制路径、框、圆、文本和添加图像的方法</p>
<hr/>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://jsbin.com/weduxufura/edit?html,console,output=">canvas demo</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;newCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid #000000;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;newCanvas&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ctx = c.getContext(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    ctx.fillStyle = <span class="string">&#x27;#1E81FF&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d10aba1ba1a4916ad0da0d5ebebf326~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><p><code>SVG</code>是一种基于<code>XML</code>中的2D图形的语言。</p>
<p><code>Canvas</code>通过脚本动态绘制2D图形。</p>
<p><code>SVG</code>是基于<code>XML</code>的，这意味着每个元素都在<code>SVG DOM</code>中可用, 可以为元素附加<code>JavaScript</code>事件处理程序。在SVG中，将每个绘制的形状记住为对象。如果更改了SVG对象的属性，则浏览器可以自动重新呈现形状。</p>
<p><code>Canvas</code>由像素呈现,一旦图形在画布中绘制完成，浏览器撒手不管了。如果需要更改其位置，则需要重新绘制整个场景，其中许多对象会被频繁重绘。</p>
<p><strong>详细对比如下：</strong></p>
<table>
<thead>
<tr>
<th>SVG</th>
<th>Canvas</th>
</tr>
</thead>
<tbody><tr>
<td>不依赖分辨率（矢量图）</td>
<td>依赖分辨率（位图）</td>
</tr>
<tr>
<td>每一个图形都是一个 <code>DOM</code>元素</td>
<td>单个HTML元素，相当于<code>&lt;img&gt;</code></td>
</tr>
<tr>
<td>支持事件处理器</td>
<td>不支持事件处理器</td>
</tr>
<tr>
<td>适合大型渲染区域的应用程序(谷歌地图)</td>
<td>文本渲染能力差</td>
</tr>
<tr>
<td>可以通过脚本和CSS进行修改</td>
<td>只能通过脚本修改</td>
</tr>
<tr>
<td>对象数量较小 (<code>&lt;10k</code>)、图面更大时性能更佳</td>
<td>图面较小，对象数量较大（<code>&gt;10k</code>）时性能最佳</td>
</tr>
<tr>
<td>不适合游戏应用</td>
<td>适合图像密集型的游戏应用</td>
</tr>
</tbody></table>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><a target="_blank" rel="noopener" href="https://caniuse.com/?search=svg">Can I use Svg ?</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e94e23b7394d24a38911645c4c2190~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><a target="_blank" rel="noopener" href="https://caniuse.com/?search=Canvas">Can I use Canvas ?</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b068616852114a3eac8ef42d4a3c5bba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://caniuse.com/">Can I use</a></p>
<p><a target="_blank" rel="noopener" href="https://www.w3schools.com/html/html5_svg.asp">W3cSchool</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">MDN</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="martisss"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">martisss</p>
  <div class="site-description" itemprop="description">孩子，快逃！！！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/martisss" title="Martisss → https:&#x2F;&#x2F;github.com&#x2F;martisss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>Martisss</a>
      </span>
  </div>



      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=441491828&auto=1&height=66"></iframe>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">martisss</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

  <script src="/js/wobblewindow.js"></script>
  <script>
    //只在桌面版网页启用特效
    if( window.innerWidth > 768  ){
      $(document).ready(function () {
        
          $('#header').wobbleWindow({
            radius: 50,
            movementTop: false,
            movementLeft: false,
            movementRight: false,
            debug: false,
          });
        

        
          $('#sidebar').wobbleWindow({
            radius: 50,
            movementLeft: false,
            movementTop: false,
            movementBottom: false,
            position: 'fixed',
            debug: false,
          });
        

        
          $('#footer').wobbleWindow({
            radius: 50,
            movementBottom: false,
            movementLeft: false,
            movementRight: false,
            offsetX: ,
            position: 'absolute',
            debug: false,
          });
        
      });
    }
  </script>

</body>
<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="800" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
</html>
